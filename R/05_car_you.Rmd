---
title: "Car"
output: github_document
params:
  year:
    value: [1952, 2007]
    min: 1952
    max: 2007
    step: 1
    sep: ""
---

**Collapse all chunks with Alt+O / Cmd+Option+O**



```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, comment = "#>")
```

Packages.

```{r}
library(tidyverse)
library(here)
library(vroom)
library(fs)
library(broom)
```

`vroom()` reads multiple datasets into a single data frame, elegantly and fast:

```{r demo-paths}
paths <- dir_ls(here("data", "by-continent"))
messy <- suppressMessages(vroom(paths))
messy
```



Do the same step by step and compare the results:

* Create a list of data frames, mapping each path to `vroom()` with `map()`.
* Use the `~` syntax to suppress the messages from `vroom()`.
* Reduce `reduce()` the list to a single data frame with `bind_rows()`.
* Pipe the output into `identical()` and compare it with `messy`.

```{r map-reduce-1, eval=FALSE}
paths %>% 
  ___(~ suppressMessages(_____(.x))) %>%
  reduce(_________) %>% 
  reduce(bind_rows) %>% 
  _________(messy)
```

```{r map-reduce-2, echo=FALSE}
paths %>% 
  map(~ suppressMessages(vroom(.x))) %>%
  reduce(bind_rows) %>% 
  identical(messy)
```



Create a longer dataset with a numeric column `year`, and one column per metric:

* Pivot, separate, and mutate `year`.
* Pivot again to move each metric to its own column.

```{r tidy-1, eval=FALSE}
tidy <- messy %>% 
  ____________(where(is.numeric)) %>% 
  ________(____, into = c("name", "year")) %>% 
  ______(year = as.numeric(____)) %>% 
  ___________(names_from = name)

tidy
```

```{r tidy-2, echo=FALSE}
tidy <- messy %>% 
  pivot_longer(where(is.numeric)) %>% 
  separate(name, into = c("name", "year")) %>% 
  mutate(year = as.numeric(year)) %>% 
  pivot_wider(names_from = name)

tidy
```



## Pick years

* Pick years in the (inclusive) range `params$min_year`-`params$max_year`.

```{r pick-params-1, eval=FALSE}
picked <- tidy %>% 
  ______(____ >= min(params$year), year <= max(______$____))
```

```{r pick-params-2, echo=FALSE}
picked <- tidy %>% 
  filter(year >= min(params$year), year <= max(params$year))
```



## Plot linear models

Plot a linear model of life expectancy through time:

* Map `group` to `country` (what happens if you don't).
* Use `geom_smooth()`; use the "lm" `method`.
* For clarity, remote the `se` shade, and reduce `alpha` and `size` to 1/3.

```{r plot-lines-1, eval=FALSE}
picked %>% 
  ggplot(aes(____, lifeExp, group = _______)) +
  ___________(method = "__", se = _____, alpha = ___, ____ = 1/3)
```

```{r plot-lines-2, echo=FALSE}
picked %>% 
  ggplot(aes(year, lifeExp, group = country)) +
  geom_smooth(method = "lm", se = FALSE, alpha = 1/3, size = 1/3)
```

> What if you actually want those mods? To access estimates, p-values, etc. In that case, you need to fit them yourself. How to do that?
> -- https://jennybc.github.io/purrr-tutorial/ls13_list-columns.html



## Compute linear models: The purrr way

Put the variables needed for country-specific models into nested data frame:

* Use `group_by()` and `nest()` to create a list column with the `country` data.
* You may inspect the list `nested$data` with `View()`.

```{r}
nested <- picked %>% 
  group_by(country) %>% 
  nest()

nested
```



* Use `map()` inside `mutate()` to fit linear models of `lifeExp` versus `year`.

```{r}
mods <- nested %>% 
  mutate(mod = map(data, ~ lm(lifeExp ~ year, data = .x)))

mods
```



* Use `map()` inside `mutate()`; apply `broom::tidy()` to get model parameters.
* Remove the needless columns `data` and `mod`.
* `unnest()` the `params` column.

```{r}
mods %>% 
  mutate(params = map(mod, broom::tidy)) %>% 
  select(-data, -mod) %>% 
  unnest(params)
```



## Compute linear models: The `rowwise()` way

> `rowwise()` data frames allow you to solve a variety of modelling problems in what I think is a particularly elegant way.
> -- https://dplyr.tidyverse.org/articles/rowwise.html#list-columns-1



* Use `nest_by()` to create a row-wise data-frame, nested by `country`.

```{r}
nested2 <- tidy %>% nest_by(country)

nested2
```

* Use `mutate()` without `map()` to pull interesting information out of each fitted linear model.
* Inspect the resulting list column `mod` with `View()`.

```{r}
mods2 <- nested2 %>% 
  mutate(mod = list(lm(lifeExp ~ year, data = data)))

mods2
```



* Use `broom::tidy()` inside `summarise()` to access model parameters.

```{r}
parameters2 <- mods2 %>% summarise(broom::tidy(mod))
parameters2
```



## Plotting from the model parameters

Here are two ways to get the r.squared from the model of each country:

```{r}
# purrr: List approach
country <- mods %>% pluck("country")
rsq <- mods %>% pluck("mod") %>% map(summary) %>% map_dbl("r.squared")
list(country, rsq) %>% map(head)

# dplyr: Data frame approach
country_rsq <- mods2 %>% summarise(rsq = summary(mod)$r.squared)
head(country_rsq)
```



The data frame approach keeps `country` and `rsq` in sync. This makes it easy to work with the two vectors at the same time. 

* `ungroup()` the dataset `country_rsq` (what happens if you don't?).
* `arrange()` to find the 3 countries with highest and lowest `rsq`.
* Use `slice_head()` and `pull()` to pull the names of those countries.

```{r}
high <- country_rsq %>% 
  ungroup() %>% 
  arrange(desc(rsq)) %>% 
  slice_head(n = 3) %>% 
  pull(country)

low <- country_rsq %>% 
  ungroup() %>% 
  arrange(rsq) %>% 
  slice_head(n = 3) %>% 
  pull(country)

high_low <- c(high, low)
high_low
```



Confirm your findings with a plot:

* `filter()` the `picked` dataset; get countries with the highest/lowest `rsq`.
* Plot a linear model with `geom_smooth()`; keep map `colour` to `country`.
* Facet each `country` into a separate panel.
* Use `theme_bw()` (or any other theme you like).

```{r}
picked %>% 
  filter(country %in% high_low) %>% 
  ggplot(aes(year, lifeExp)) + 
  geom_smooth(method = "lm") +
  facet_wrap(~country) +
  theme_bw()
```



The data frame is a very flexible data structure; can can store anythingn in it:

Let's save each plot in a single .png file. Let's first create a helper function to make the plot for each country, and also create the paths to the plots we'll soon save.

```{r}
make_plot <- function(data) {
  data %>% 
    ggplot(aes(year, lifeExp)) + 
    geom_smooth(method = "lm") +
    theme_bw()
}

# Ensure the parent directory exists, or create it
if (!dir_exists(here("output"))) {
  dir_create(here("output"))
}
```



```{r}
plots_df <- picked %>% 
  filter(country %in% high_low) %>%
  nest_by(country) %>% 
  summarise(plot = list(make_plot(data))) %>% 
  ungroup() %>%
  mutate(filename = here("output", glue("{country}.png"))) %>% 
  select(-country)

plots_df
```


We can now use both a list and data frame approach to saving the plots:

- List approach:

```{r}
# Nothing plots
dir_ls(here("output"))

pwalk(plots_df, ggsave)

# Confirm
dir_ls(here("output"))
# Cleanup
file_delete(dir_ls(here("output")))
```

- Data frame approach:

```{r}
# Nothing plots yet
dir_ls(here("output"))

plots_df %>% 
  rowwise() %>% 
  summarise(trash = list(suppressMessages(ggsave(filename, plot))))

# Confirm
dir_ls(here("output"))

# Cleanup
file_delete(dir_ls(here("output")))
```



* Knit with params and set the year range however you like.
