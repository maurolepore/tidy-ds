---
title: "Motorbike"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Packages.

```{r}
library(tidyverse)
library(here)
library(fs)
library(vroom)
```



## Warm up

This toy dataset is messy. Why?

```{r demo-toy}
toy <- tribble(
  ~country, ~"2011", ~"2012", ~"2013",
      "fr",    7000,    6900,    7000,
      "de",    5800,    6000,    6200,
      "us",   15000,   14000,   13000
)
```

To tidy this dataset we pivot over all columns except `country`. We may exclude `country` with `-` or select all other columns with `where(is.numeric)`.

```{r}
toy %>% pivot_longer(where(is.numeric))
```

This dataset is now tidy.



## Import

Import all datasets in "data/by-continent" into a single data frame: `messy`.

```{r}
paths <- dir_ls(here("data", "by-continent"))
paths

messy <- vroom(paths)
```



## Tidy

* Pivot over all numeric columns.
* Store the result as `longer`.
* Use `names_to = metric` (see `?pivot_longer()`).

```{r longer-1}



```

```{r longer-2, eval=FALSE}
longer <- messy %>% 
  ____________(where(__________), ________ = "metric")

longer
```

```{r longer-3, echo=FALSE}
longer <- messy %>% 
  pivot_longer(where(is.numeric), names_to = "metric")

longer
```



* `metric` is still messy; tidy it with `separate()` and `c("metric", "year")`.
* Store the result as `tidy`.

```{r separate-1}


```

```{r separate-2, eval=FALSE}
tidy <- longer %>% ________(______, c("metric", "____"))
tidy
```

```{r separate-3, echo=FALSE}
tidy <- longer %>% separate(metric, c("metric", "year"))
tidy
```



Mess things up again:

* Use `unite()` to unite the columns `metric` and `year` as "metric".
* Use `pivot_wider()` to take the `names_from` the column `metric` and create new columns -- taking `values_from` the column `value`.
* Is the output wider than the input?

```{r mess-up-1}



```

```{r mess-up-2, eval=FALSE}
tidy %>% 
  _____("metric", ______, year) %>% 
  ___________(names_from = ______, values_from = _____)
```

```{r mess-up-3, echo=FALSE}
tidy %>% 
  unite("metric", metric, year) %>% 
  pivot_wider(names_from = metric, values_from = value)
```



## Create a small dataset to play with

Let's create a small dataset to play with. Explain what this code does.

You should already understand this code:

- Remove `continent`.
- Subset life expectancy values for Argentina and Germany before 1962.
- Move the life expectancy values to the column `lifeExp`.

```{r}
subset1 <- tidy %>% 
  select(-continent) %>% 
  filter(
    country %in% c("Argentina", "Germany"), 
    metric == "lifeExp",
    year < 1962
  ) %>% 
  pivot_wider(names_from = metric)

subset1
```



Now add a new column `mean`, holding the mean life expectancy for each country:

* Use `group_by()`.
* Use `mutate()` to calculate mean `lifeExp` and to make `year` numeric.
* `ungroup()`.
* Store the result as `subset2`.

```{r group-mutate-1}
subset2 <- subset1 %>% 
  group_by(country) %>% 
  mutate(mean = mean(lifeExp), year = as.numeric(year)) %>% 
  ungroup()

subset2
```

```{r group-mutate-2, eval=FALSE}
subset2 <- subset1 %>% 
  ________(country) %>% 
  ______(mean = ____(lifeExp), year = as.numeric(____)) %>% 
  _______()

subset2
```

```{r group-mutate-3, echo=FALSE}
subset2 <- subset1 %>% 
  group_by(country) %>% 
  mutate(mean = mean(lifeExp), year = as.numeric(year)) %>% 
  ungroup()

subset2
```



I now degrade this dataset a bit for a later example.

```{r}
subset3 <- subset2 %>% slice(-2)
subset3
```



## `complete()`

Say you start with this dataset, and you care for data between 1952 and 1957:

```{r}
subset3
```

This dataset has implicit missing for Argentina in 1957.



* Make the implicit missing data explicit with `complete()`.

```{r complete-1}

```
```{r complete-2, eval=FALSE}
subset3 %>% ________(_______, year)
```

```{r complete-3, echo=FALSE}
subset3 %>% complete(country, year)
```



Extend the previous code:

* Use the argument `fill`, and fill the missing data with Argentina's `mean`.
* You may `filter()` data from Argentina an `pull()` the `mean`.
* You'll need to pass each value to fill as a named list.
* Store the result as `filled`.

```{r fill-1}




```

```{r fill-2, eval=FALSE}
mean_arg <- subset3 %>% ______(country == "_________") %>% ____(mean)

filled <- subset3 %>% 
  ________(country, year, fill = list(lifeExp = ________, ____ = mean_arg))
```

```{r fill-3, echo=FALSE}
mean_arg <- subset3 %>% filter(country == "Argentina") %>% pull(mean)

filled <- subset3 %>% 
  complete(country, year, fill = list(lifeExp = mean_arg, mean = mean_arg))
```



You lack data in between 1952-1957:

* Use `pull()` to  pull the available years.
* Use `full_seq()` to produce the full sequence of every year in the range.
* Store the result as `all_years`.

```{r full-seq-1}



```

```{r full-seq-2, eval=FALSE}
all_years <- filled %>% 
  ____(year) %>% 
  ________(period = 1)

all_years
```

```{r full-seq-3, echo=FALSE}
all_years <- filled %>% 
  pull(year) %>% 
  full_seq(period = 1)

all_years
```



* Use `all_years` to `complete()` `year`; also complete `country` with itself.

TODO
  
```{r all-years-3}
filled2 <- filled %>% 
  complete(year = all_years, country = country)

filled2
```



This code uses other two approaches to fill data: `if_else()` and `case_when()`:

```{r}
mean_ger <- means %>% filter(country == "Germany") %>% pull(mean)

filled %>% 
  complete(year = all_years, country = country) %>% 
  mutate(mean = if_else(country == "Argentina", mean_arg, mean_ger)) %>%
  mutate(
    lifeExp = case_when(
      is.na(.data$lifeExp) & .data$country == "Argentina" ~ mean_arg,
      is.na(.data$lifeExp) & .data$country == "Germany"   ~ mean_ger,
      TRUE                                                ~ lifeExp
    )
  )
```



***

# Take Aways

Data comes in many formats but the tidyverse prefers just one: _tidy data_.

A data set is tidy if and only if:

1. Every variable is in its own column.
2. Every observation is in its own row.
