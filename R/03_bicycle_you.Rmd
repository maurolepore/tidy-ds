---
title: "Motorbike"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, collapse = TRUE, comment = "#>")
```

Packages.

```{r}
library(tidyverse)
library(here)
library(fs)
library(vroom)
```



## Warm up

This toy dataset is messy. Why?

```{r demo-toy}
toy <- tribble(
  ~country, ~"2011", ~"2012", ~"2013",
      "fr",    7000,    6900,    7000,
      "de",    5800,    6000,    6200,
      "us",   15000,   14000,   13000
)
```

To tidy this dataset we pivot over all columns except `country`. We may exclude `country` with `-` or select all other columns with `where(is.numeric)`.

```{r}
toy %>% pivot_longer(where(is.numeric))
```

This dataset is now tidy.



## Import

Import all datasets in "data/by-continent" into a single data frame: `messy`.

```{r}
paths <- dir_ls(here("data", "by-continent"))
paths

messy <- vroom(paths)
```



## Tidy

* Pivot over all numeric columns.
* Store the result as `longer`.
* Use `names_to = metric` (see `?pivot_longer()`).

```{r longer-1, eval=FALSE}
longer <- messy %>% 
  ____________(where(__________), ________ = "metric")

longer
```

```{r longer-2, echo=FALSE}
longer <- messy %>% 
  pivot_longer(where(is.numeric), names_to = "metric")

longer
```



* `metric` is still messy; tidy it with `separate()` and `c("metric", "year")`.
* Store the result as `tidy`.

```{r separate-1, eval=FALSE}
tidy <- longer %>% ________(______, c("metric", "____"))
tidy
```

```{r separate-2, echo=FALSE}
tidy <- longer %>% separate(metric, c("metric", "year"))
tidy
```



Mess things up again:

* Use `unite()` to unite the columns `metric` and `year` as "metric".
* Use `pivot_wider()` to take the `names_from` the column `metric` and create new columns -- taking `values_from` the column `value`.
* Is the output wider than the input?

```{r mess-up-1, eval=FALSE}
tidy %>% 
  _____("metric", ______, year) %>% 
  ___________(names_from = ______, values_from = _____)
```

```{r mess-up-2, echo=FALSE}
tidy %>% 
  unite("metric", metric, year) %>% 
  pivot_wider(names_from = metric, values_from = value)
```



## Create a small dataset to play with

Let's create a small dataset to play with. Explain what this code does.

You should already understand this code:

- Remove `continent`.
- Subset life expectancy values for Argentina and Germany before 1962.
- Move the life expectancy values to the column `lifeExp`.

```{r}
subset1 <- tidy %>% 
  select(-continent) %>% 
  filter(
    country %in% c("Argentina", "Germany"), 
    metric == "lifeExp",
    year < 1962
  ) %>% 
  pivot_wider(names_from = metric)

subset1
```



Now add a new column `mean`, holding the mean life expectancy for each country:

* Use `group_by()`.
* Use `mutate()` to calculate mean `lifeExp` and to make `year` numeric.
* `ungroup()`.
* Store the result as `subset2`.

```{r group-mutate-1, eval=FALSE}
subset2 <- subset1 %>% 
  ________(country) %>% 
  ______(mean = ____(lifeExp), year = as.numeric(____)) %>% 
  _______()

subset2
```

```{r group-mutate-2, echo=FALSE}
subset2 <- subset1 %>% 
  group_by(country) %>% 
  mutate(mean = mean(lifeExp), year = as.numeric(year)) %>% 
  ungroup()

subset2
```



Let's degrade this dataset a bit for a later example.

```{r}
subset3 <- subset2 %>% slice(-2)
subset3
```



## `complete()`

Say you start with this dataset, and you care for data between 1952 and 1957:

```{r}
subset3
```

This dataset has implicit missing for Argentina in 1957.



* Make the implicit missing data explicit with `complete()`.

```{r complete-1, eval=FALSE}
subset3 %>% ________(_______, year)
```

```{r complete-2, echo=FALSE}
subset3 %>% complete(country, year)
```



Extend the previous code:

* Use the argument `fill`, and fill the missing data with Argentina's `mean`.
* You may `filter()` data from Argentina an `pull()` the `mean`.
* You'll need to pass each value to fill as a named list.
* Store the result as `filled`.

```{r fill-1, eval=FALSE}
mean_arg <- subset3 %>% ______(country == "_________") %>% ____(mean)

filled <- subset3 %>% 
  ________(country, year, fill = list(lifeExp = ________, ____ = mean_arg))
```

```{r fill-2, echo=FALSE}
mean_arg <- subset3 %>% filter(country == "Argentina") %>% pull(mean)

filled <- subset3 %>% 
  complete(country, year, fill = list(lifeExp = mean_arg, mean = mean_arg))
```



Let's now complete the missing data in between 1952-1957.

* Use `pull()` to  pull the available years.
* Use `full_seq()` to produce the full sequence of every year in the range.
* Store the result as `all_years`.

```{r full-seq-1, eval=FALSE}
all_years <- filled %>% 
  ____(year) %>% 
  ________(period = 1)

all_years
```

```{r full-seq-2, echo=FALSE}
all_years <- filled %>% 
  pull(year) %>% 
  full_seq(period = 1)

all_years
```



* Use `all_years` to `complete()` `year`; also complete `country` with itself.
* `fill()` values of `mean` for each `country`.
* What happens if your forget to `group_by()`?
* Store the result as `full_mean`.

```{r all-years-1, eval=FALSE}
full_mean <- filled %>% 
  ________(year = _________, country = _______) %>% 
  ________(country) %>%
  ____(mean)

full_mean
```

```{r all-years-2, echo=FALSE}
full_mean <- filled %>% 
  complete(year = all_years, country = country) %>% 
  group_by(country) %>%
  fill(mean)

full_mean
```



* `pull()` the `mean` `lifeExp` for "Germany" and store it as `mean_ger`
* Fill `lifeExp` with corresponding values of `mean`, using `case_when()`.
* There are 3 cases: the result should be `mean_arg`, `mean_ger`, or `lifeExp`.
* Store the result as `full`.

```{r full-1, eval=FALSE}
mean_ger <- subset3 %>% 
  ________(country, mean) %>% 
  ______(country == "Germany") %>% 
  ____(mean)

other <- TRUE

full <- full_mean %>% 
  mutate(
    lifeExp = _________(
      is.na(lifeExp) & country == "Argentina" ~ ________,
      is.na(lifeExp) & country == "Germany"   ~ ________,
      other                                   ~ lifeExp
    )
  )

full
```

```{r full-2, echo=FALSE}
mean_ger <- subset3 %>% 
  distinct(country, mean) %>% 
  filter(country == "Germany") %>% 
  pull(mean)

other <- TRUE

full <- full_mean %>% 
  mutate(
    lifeExp = case_when(
      is.na(lifeExp) & country == "Argentina" ~ mean_arg,
      is.na(lifeExp) & country == "Germany"   ~ mean_ger,
      other                                   ~ lifeExp
    )
  )

full
```



## Plot

* Make a line-plot of `year` versus `lifeExp`.
* Add a dotted line intercepting `y` at the `mean` value for each `country`.
* Use `facet_wrap()` to plot each country in a separate panel.

```{r line-2, echo=FALSE}
full %>% 
  ggplot(aes(year, lifeExp)) + 
  geom_line() +
  geom_hline(aes(yintercept = mean), linetype = "dotted") +
  facet_wrap(~country)
```



***

# Take Aways

Data comes in many formats but the tidyverse prefers just one: _tidy data_.

A data set is tidy if and only if:

1. Every variable is in its own column.
2. Every observation is in its own row.
